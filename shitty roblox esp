from ctypes import wintypes
from pyglet import gl
import math

import win32process # type: ignore
import threading
import win32gui # type: ignore
import win32con # type: ignore
import requests
import psutil
import ctypes
import pyglet
import struct
import time
import json

# --- CONFIGURATION ---
OFFSETS_URL = "https://robloxoffsets.com/offsets.json"
try:
    OFFSETS = requests.get(OFFSETS_URL, timeout=5).json()
except:
    print("Failed to fetch offsets from URL, ensure internet connection or valid URL.")
    OFFSETS = {}

TEAM_CHECK = False
PLAYER_CACHE_INTERVAL = 0.005 

COLOR_DOT = (255, 0, 255) 
COLOR_TEXT = (255, 255, 255, 255)
DOT_RADIUS = 1

# --- LUT CONFIGURATION CLASS ---
class GlobalConfig:
    def __init__(self):
        # Hardcoded offsets provided by user
        # Keys converted to integers for correct lookup
        self.offset_map = {
            0: -200.0,
            10: -70.0,
            20: -30.0,
            30: -15.0,
            40: 0.0,
            50: 2.0,
            60: 6.0,
            70: 8.0,
            80: 10.0,
            90: 12.0,
            100: 11.8,
            110: 12.0,
            120: 15.0,
            130: 16.0,
            140: 16.0,
            150: 17.5,
            160: 15.8,
            170: 17.8,
            180: 17.0,
            190: 18.2,
            200: 20.0,
            210: 18.0,
            220: 18.7,
            230: 18.7,
            240: 17.9,
            250: 20.0,
            260: 19.5,
            270: 19.3,
            280: 19.4,
            290: 19.3,
            300: 19.5,
            310: 20.5,
            320: 20.1,
            330: 20.5,
            340: 20.3,
            350: 19.5
        }

    def get_interpolated_offset(self, distance):
        # 1. Clamp distance to range [0, 350]
        if distance <= 0:
            return self.offset_map[0]
        if distance >= 350:
            return self.offset_map[350]

        # 2. Find lower and upper bounds (e.g., if dist is 15, bounds are 10 and 20)
        lower_dist = (int(distance) // 10) * 10
        upper_dist = lower_dist + 10

        # 3. Get values
        val_low = self.offset_map.get(lower_dist, 0.0)
        val_high = self.offset_map.get(upper_dist, 0.0)

        # 4. Linear Interpolation (Lerp)
        ratio = (distance - lower_dist) / 10.0
        return val_low + (val_high - val_low) * ratio

config = GlobalConfig()

class MODULEENTRY32(ctypes.Structure):
    _fields_ = [
        ("dwSize", wintypes.DWORD),
        ("th32ModuleID", wintypes.DWORD),
        ("th32ProcessID", wintypes.DWORD),
        ("GlblcntUsage", wintypes.DWORD),
        ("ProccntUsage", wintypes.DWORD),
        ("modBaseAddr", ctypes.POINTER(wintypes.BYTE)),
        ("modBaseSize", wintypes.DWORD),
        ("hModule", wintypes.HMODULE),
        ("szModule", ctypes.c_char * 256),
        ("szExePath", ctypes.c_char * 260)
    ]

class Vec2:
    __slots__ = ('x', 'y')
    def __init__(self, x=0.0, y=0.0):
        self.x = x
        self.y = y

class Vec3:
    __slots__ = ('x', 'y', 'z')
    def __init__(self, x=0.0, y=0.0, z=0.0):
        self.x = x
        self.y = y
        self.z = z

    def dist(self, other):
        return math.sqrt((self.x - other.x)**2 + (self.y - other.y)**2 + (self.z - other.z)**2)

class RobloxMemory:
    def __init__(self):
        self.process_handle = None
        self.base_address = None
        self.data_model = None
        self.visual_engine = None
        self.workspace = None
        self.players = None
        self.local_player = None
        self.hwnd = None
        self._view_matrix_cache = None
        self._view_matrix_time = 0.0
        self._player_cache = []
        self._cache_time = 0.0
        
        if not self.find_roblox_process():
            raise Exception("Roblox process not found")
        self.initialize_game_data()

    def _o(self, key):
        val = OFFSETS.get(key, "0x0")
        return int(val, 16) if isinstance(val, str) else val

    def find_roblox_process(self):
        hwnd, pid = self._find_window_by_exe("RobloxPlayerBeta.exe")
        if not pid:
            pid = self._get_process_id_by_psutil("RobloxPlayerBeta.exe")
            if not pid:
                return False
            hwnd, _ = self._find_window_by_exe("RobloxPlayerBeta.exe")
        
        self.hwnd = hwnd
        self.process_id = pid
        
        self.process_handle = ctypes.windll.kernel32.OpenProcess(
            win32con.PROCESS_ALL_ACCESS, False, self.process_id
        )
        if not self.process_handle:
            return False
        
        self.base_address = self._get_module_address("RobloxPlayerBeta.exe")
        if not self.base_address:
            ctypes.windll.kernel32.CloseHandle(self.process_handle)
            return False
        return True

    def _find_window_by_exe(self, exe_name):
        matches = []
        def enum_proc(hwnd, _):
            try:
                _, pid = win32process.GetWindowThreadProcessId(hwnd)
                p = psutil.Process(pid)
                if p.name().lower() == exe_name.lower():
                    matches.append((hwnd, pid))
            except:
                pass
            return True
        
        win32gui.EnumWindows(enum_proc, None)
        return matches[0] if matches else (None, None)

    def _get_process_id_by_psutil(self, process_name):
        for proc in psutil.process_iter(['pid', 'name']):
            if proc.info['name'].lower() == process_name.lower():
                return proc.info['pid']
        return None

    def _get_module_address(self, module_name):
        snapshot = ctypes.windll.kernel32.CreateToolhelp32Snapshot(0x18, self.process_id)
        if snapshot == -1:
            return None
        
        module_entry = MODULEENTRY32()
        module_entry.dwSize = ctypes.sizeof(MODULEENTRY32)
        
        if ctypes.windll.kernel32.Module32First(snapshot, ctypes.byref(module_entry)):
            while True:
                name = module_entry.szModule.decode().lower()
                if module_name.lower() == name:
                    ctypes.windll.kernel32.CloseHandle(snapshot)
                    return ctypes.addressof(module_entry.modBaseAddr.contents)
                if not ctypes.windll.kernel32.Module32Next(snapshot, ctypes.byref(module_entry)):
                    break
        
        ctypes.windll.kernel32.CloseHandle(snapshot)
        return None

    def read_memory(self, address, size):
        buffer = ctypes.create_string_buffer(size)
        bytes_read = ctypes.c_size_t()
        result = ctypes.windll.kernel32.ReadProcessMemory(
            self.process_handle, ctypes.c_void_p(address), 
            buffer, size, ctypes.byref(bytes_read)
        )
        return buffer.raw[:bytes_read.value] if result and bytes_read.value > 0 else None

    def read_ptr(self, address):
        data = self.read_memory(address, 8)
        return int.from_bytes(data, 'little') if data else None

    def read_int(self, address):
        data = self.read_memory(address, 4)
        return int.from_bytes(data, 'little', signed=True) if data else None

    def read_string(self, address):
        if not address:
            return ""
        str_length = self.read_int(address + 0x18)
        if not str_length or str_length <= 0 or str_length > 1000:
            return ""
        
        if str_length >= 16:
            address = self.read_ptr(address)
            if not address:
                return ""
        
        data = self.read_memory(address, min(str_length, 1000))
        if not data:
            return ""
        
        try:
            null_pos = data.index(0)
            data = data[:null_pos]
        except ValueError:
            pass
        
        return data.decode('utf-8', errors='ignore').strip()

    def initialize_game_data(self):
        fake_dm = self.read_ptr(self.base_address + self._o("FakeDataModelPointer"))
        if not fake_dm or fake_dm == 0xFFFFFFFF:
            return
        
        dm_ptr = self.read_ptr(fake_dm + self._o("FakeDataModelToDataModel"))
        if not dm_ptr or dm_ptr == 0xFFFFFFFF:
            return
        
        for _ in range(30):
            name_ptr = self.read_ptr(dm_ptr + self._o("Name"))
            dm_name = self.read_string(name_ptr)
            if "Ugc" in dm_name or dm_name == "Ugc":
                break
            time.sleep(1)
            fake_dm = self.read_ptr(self.base_address + self._o("FakeDataModelPointer"))
            if fake_dm:
                dm_ptr = self.read_ptr(fake_dm + self._o("FakeDataModelToDataModel"))
        else:
            return
        
        self.data_model = dm_ptr
        self.visual_engine = self.read_ptr(self.base_address + self._o("VisualEnginePointer"))
        self.workspace = self._find_first_child_of_class(self.data_model, "Workspace")
        self.players = self._find_first_child_of_class(self.data_model, "Players")
        
        if self.players:
            self.local_player = self.read_ptr(self.players + self._o("LocalPlayer"))

    def _get_children(self, parent):
        if not parent:
            return []
        children_ptr = self.read_ptr(parent + self._o("Children"))
        if not children_ptr:
            return []

        start = self.read_ptr(children_ptr)
        end = self.read_ptr(children_ptr + self._o("ChildrenEnd"))
        if not start or not end or end <= start:
            return []

        def walk(stride):
            out = []
            cur = start
            while cur and cur < end:
                child = self.read_ptr(cur)
                if child:
                    out.append(child)
                cur += stride
            return out

        first = walk(0x10)
        if len(first) > 1:
            return first
        second = walk(0x8)
        return second if len(second) > len(first) else first

    def _get_instance_name(self, address):
        name_ptr = self.read_ptr(address + self._o("Name"))
        return self.read_string(name_ptr) if name_ptr else ""

    def _get_instance_class(self, address):
        class_desc = self.read_ptr(address + self._o("ClassDescriptor"))
        if class_desc:
            class_name_ptr = self.read_ptr(class_desc + self._o("ClassDescriptorToClassName"))
            return self.read_string(class_name_ptr) if class_name_ptr else ""
        return ""

    def _find_first_child_of_class(self, parent, class_name):
        for child in self._get_children(parent):
            if self._get_instance_class(child) == class_name:
                return child
        return None

    def _find_first_child_by_name(self, parent, name):
        for child in self._get_children(parent):
            if self._get_instance_name(child) == name:
                return child
        return None

    def read_matrix4(self, address):
        data = self.read_memory(address, 64)
        return [struct.unpack('f', data[i*4:(i+1)*4])[0] for i in range(16)] if data else None

    def get_view_matrix(self):
        now = time.time()
        if self._view_matrix_cache and now - self._view_matrix_time < 0.001:
            return self._view_matrix_cache
        if not self.visual_engine:
            return None
        matrix = self.read_matrix4(self.visual_engine + self._o("viewmatrix"))
        if matrix:
            self._view_matrix_cache = matrix
            self._view_matrix_time = now
        return matrix

    def _get_player_pos(self, player_ptr):
        try:
            character_ptr = self.read_ptr(player_ptr + self._o("ModelInstance"))
            if not character_ptr or self._get_instance_class(character_ptr) != "Model":
                return None
            
            hrp = self._find_first_child_by_name(character_ptr, "HumanoidRootPart")
            if not hrp or self._get_instance_class(hrp) != "Part":
                return None
            
            primitive = self.read_ptr(hrp + self._o("Primitive"))
            if not primitive:
                return None
            
            pos_data = self.read_memory(primitive + self._o("Position"), 12)
            if not pos_data:
                return None
            
            x, y, z = struct.unpack('fff', pos_data)
            return Vec3(x, y, z)
        except:
            return None

    def get_player_data(self):
        now = time.time()
        if now - self._cache_time < PLAYER_CACHE_INTERVAL:
            return self._player_cache
        
        if not self.players or not self.local_player:
            self._player_cache = []
            return []

        lp_pos = self._get_player_pos(self.local_player)

        local_team_name = None
        if TEAM_CHECK:
            try:
                lp_team_ptr = self.read_ptr(self.local_player + self._o("Team"))
                if lp_team_ptr:
                    local_team_name = self._get_instance_name(lp_team_ptr)
            except:
                pass
        
        players_data = []
        for player_ptr in self._get_children(self.players):
            if player_ptr == self.local_player:
                continue

            try:
                team_ptr = self.read_ptr(player_ptr + self._o("Team"))
                team_name = self._get_instance_name(team_ptr) if team_ptr else ""
                if TEAM_CHECK and local_team_name and team_name == local_team_name:
                    continue
            except:
                pass
            
            target_pos = self._get_player_pos(player_ptr)
            if not target_pos:
                continue
            
            dist = 0
            if lp_pos:
                dist = lp_pos.dist(target_pos)

            players_data.append({
                "center_pos": target_pos,
                "distance": dist
            })
        
        self._player_cache = players_data
        self._cache_time = now
        return players_data

    def get_viewport(self):
        if not self.hwnd:
            return Vec2(1920, 1080)
        try:
            left, top, right, bottom = win32gui.GetClientRect(self.hwnd)
            width = right - left
            height = bottom - top
            return Vec2(float(width), float(height)) if width > 0 and height > 0 else Vec2(1920, 1080)
        except:
            return Vec2(1920, 1080)

    def world_to_screen(self, pos, matrix=None, viewport=None):
        if not self.visual_engine:
            return Vec2(-1, -1)
        
        matrix = matrix or self.get_view_matrix()
        if not matrix:
            return Vec2(-1, -1)
        
        qx = pos.x * matrix[0] + pos.y * matrix[1] + pos.z * matrix[2] + matrix[3]
        qy = pos.x * matrix[4] + pos.y * matrix[5] + pos.z * matrix[6] + matrix[7]
        qw = pos.x * matrix[12] + pos.y * matrix[13] + pos.z * matrix[14] + matrix[15]
        
        if qw < 0.1:
            return Vec2(-1, -1)
        
        viewport = viewport or self.get_viewport()
        x = (viewport.x / 2.0) * (1.0 + qx / qw)
        y = (viewport.y / 2.0) * (1.0 - qy / qw)
        
        return Vec2(x, y) if 0 <= x <= viewport.x and 0 <= y <= viewport.y else Vec2(-1, -1)

class ESPOverlay:
    def __init__(self, memory):
        self.memory = memory
        viewport = memory.get_viewport()
        self.width = int(viewport.x)
        self.height = int(viewport.y)
        
        config = pyglet.gl.Config(double_buffer=True, sample_buffers=0, samples=0)
        self.window = pyglet.window.Window(
            width=self.width,
            height=self.height,
            style=pyglet.window.Window.WINDOW_STYLE_BORDERLESS,
            caption="ESP Overlay",
            config=config,
            vsync=True 
        )
        
        hwnd = self.window._hwnd
        ex_style = win32gui.GetWindowLong(hwnd, win32con.GWL_EXSTYLE)
        win32gui.SetWindowLong(hwnd, win32con.GWL_EXSTYLE,
                               ex_style | win32con.WS_EX_LAYERED | win32con.WS_EX_TRANSPARENT | win32con.WS_EX_TOPMOST)
        color_key = 0x00000000
        win32gui.SetLayeredWindowAttributes(hwnd, color_key, 0, win32con.LWA_COLORKEY)
        win32gui.SetWindowPos(hwnd, win32con.HWND_TOPMOST, 0, 0, self.width, self.height, 
                              win32con.SWP_SHOWWINDOW)
        
        self.player_cache = []
        self.cache_lock = threading.Lock()
        
        gl.glEnable(gl.GL_BLEND)
        gl.glBlendFunc(gl.GL_SRC_ALPHA, gl.GL_ONE_MINUS_SRC_ALPHA)
        gl.glDisable(gl.GL_DEPTH_TEST)
        
        @self.window.event
        def on_draw():
            self.window.clear()
            gl.glClearColor(0, 0, 0, 0)
            self.render()
        
        @self.window.event
        def on_key_press(symbol, modifiers):
            if symbol == pyglet.window.key.ESCAPE:
                self.window.close()
        
        pyglet.clock.schedule_interval(self.update_players, PLAYER_CACHE_INTERVAL)
        pyglet.clock.schedule(self.update) 

    def draw_dot(self, x, y):
        draw_y = self.height - y
        circle = pyglet.shapes.Circle(x, draw_y, radius=DOT_RADIUS, color=COLOR_DOT)
        circle.draw()

    def draw_text(self, x, y, text):
        draw_y = self.height - y - 10 
        label = pyglet.text.Label(
            text,
            font_name='Arial',
            font_size=9,
            x=x, y=draw_y,
            anchor_x='center', anchor_y='top',
            color=COLOR_TEXT
        )
        label.draw()

    def update_players(self, dt):
        try:
            data = self.memory.get_player_data()
            with self.cache_lock:
                self.player_cache = data
        except:
            pass

    def render(self):
        matrix = self.memory.get_view_matrix()
        viewport = self.memory.get_viewport()
        with self.cache_lock:
            players_snapshot = list(self.player_cache)
        
        for player in players_snapshot:
            screen_pos = self.memory.world_to_screen(player["center_pos"], matrix, viewport)
            
            if screen_pos.x > 0:
                # --- INTERPOLATION LOGIC ---
                dist = player['distance']
                
                # Fetch the interpolated offset for this exact distance
                y_offset = config.get_interpolated_offset(dist)
                
                final_x = screen_pos.x
                final_y = screen_pos.y + y_offset

                self.draw_dot(final_x, final_y)
                dist_str = f"{int(dist)}m"
                self.draw_text(final_x, final_y, dist_str)

    def update(self, dt):
        try:
            self.window.invalid = True
        except:
            pass

    def run(self):
        pyglet.app.run()

def main():
    try:
        memory = RobloxMemory()
        overlay = ESPOverlay(memory)
        overlay.run()
    except Exception as e:
        print(f"Error: {e}")
        import traceback
        traceback.print_exc()

if __name__ == "__main__":
    main()
